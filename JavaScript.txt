자바스크립트
> 가장 중요한 것: 입력 출력
    > 자료형을 배우는 이유: 어떤 형이 들어오는지, 어떻게 내보내야할지 판단하기 위해
> 표현식
    > 문장: 표현식 하나 이상 모일 경우, 마지막 종결 의미로 세미콜론!
        - ex) let name = "최" + "서" + "연";
        - ex) 10 + 20 + 30 +2;
        - ex) console.log("Hello World....!");
        *다음에 다른 명령문이 오면 보통 알기는 함.
> 키워드(pre-defined)
    > break else 등등 
> 식별자
    > 이름 규칙
        > 키워드 안됨
        > 특수 문자는 _와 $만 허용
        > 숫자로 시작 안됨
        > 공백은 입력하면 안됨
    > 사용 규칙
        > 생성자 함수는 항상 대문자로 시작
        > 변수, 함수, 속성, 메소드의 이름은 항상 소문자로 시작
        > 여러 단어로 된 식별자는 각 단어의 첫 글자를 대문자로 함
> 주석
    > 한줄 처리 => //주석 | 프로그램의 제목/함수 제목 등
    > 여러 줄 주석 처리 => /*
                            주석
                            주석
                          */        | 어려웠던 부분/꼭 기억해야하는 사항/디버깅 포인트 등
> 출력 메소드
    > console 객체의 log() 메소드 사용: console.log() 메소드
>REPL을 사용한 출력
    > c:\> node
        > "안녕" + "하세요"
> 숫자: 가장 기본적인 자료형
    > ex) console.log(52) console.log(52.745)
> 연산자 우선 순위
    > * / % 우선 + - 
> 문자열
    > 문자의 집합
    > 큰따옴표 작은따음표 사용
        > but 문자 중 강조(""나 '')을 하려면 사용한 이전에 사용한 것과 다르게 사용해야함.
            > ex) console.log("This is 'String'")
            > ex) console.log('This is "String"')
    > 이스케이프 문자  
        > 따옴표를 문자 그대로 사용 가능
        > 문자열 줄바꿈 할 경우
            > ex) \" \' \n(enter) \t(tap) \\(역슬래시)
    > 문자열 합하기
        > ex) console.log("가나" + "다라" + "마바" +"사") | 각 문자열 사이를 ' '로 띄워야함
    > 문자 선택 연산자
        > 문자열[숫자]
            >ex) console.log("안녕하세요"[1]) >> 녕
    > 템플릿 문자열: [ECMAScript6]
        > `(역 작은따옴표)
        > 이 안에 ${}로 표현식을 사용 가능
            > ex) `52 + 273 = ${52 + 273}`
                >> `52 + 273 = 352`
            > ex) `올해는 ${new Date().getFullYear()}년입니다.`
                >> `올해는 2021년입니다.`
> 불
    > 참과 거짓을 표현(true == 1, false == 0)
    > 비교 연산자
        > == 같다
        > != 다르다
        > > 왼쪽 피연산자가 크다
        > < 오른쪽 피연산자가 크다
        > >= 왼쪽 피연사자가 크거나 같다
        > <= 오른쪽 피연사자가 크거나 같다
        > 문자열 비교시 => 사전 순서 (가마 < 하마)
    > 논리 연산자
        > ! 부정 연산자(not)
        > || 논리합 연산자(or)  | 둘다 flase가 언제인지
        > && 논리 곱 연산자(and)| 둘다 true가 언제인지
    > 논리 연산자가 많이 사용되는 부분은 '범위 판단'
        > ex) 30>20>10
             (30 > 20) > 10
             true > 10
             1 > 10             | 자동 형변환(불 > 숫자)
             false
             >> 비교 연산자가 여러 개 있을 때 왼쪽부터 차례대로 연산하며 발생하는 문제
    > 논리 연산자 사용 : 법위를 사용하기 위해
        > ex) x<3 || 8<x
        > ex) 3<x && x<8
> 변수: 값을 저장할 때 사용하는 식별자, 변수 선언 후 변수에 값을 할당
    > 변수 선언 => let (식별자);
        > 변수 pi 선언 => let pi;
                         undefined
        > 변수 pi 값을 할당 => pi = 3.142592;
        > 변수 초기화 => let pi = 3.1241592;
                         undefined
> 복합 대입 연산자가 
    > += 덧셈 후 대입
    > -= 뺄셈 후 대입
    > *= 곱셈 후 대입
    > /= 나눗셈 후 대입

    > += 문자열 연결 후 대입|ex) "안녕" + "하세요";
> 증감 연산자
    > 변수++: 변수를 사용하고 +1(후위)
    > ++변수: +1 후 변수 사용   (전위)
    > 변수--: 변수를 사용하고 -1(후위)
    > --변수: -1 후 변수 사용   (전위)
> 자료형 확인 연산자
    > typeof(대상) | ex) typeof(-10)
    > 여섯 가지 자료형
        > string: 문자열
        > number: 숫자
        > boolean: 불
        > function: 함수
        > object: 객체
        > undefined: 선언만 하고 할당을 하지 않은 것
> 강제 자료형 변환
    > Number(): 숫자로 자료형 변환
    > String(): 문자열로 자료형 변환
    > Boolean(): 불로 자료형 변환
        >> 0, NaN, ""(빈 문자열), null, undefined 는 false 변환

    > console.log(Number("안녕하세요")); => NaN
        >> "안녕하세요"를 숫자로 변환했지만, 숫자로 할 수 없는...
        >> NaN은 숫자형임
        >> NaN은 무조건적으로 다름(NaN == NaN => false)
        >> isNaN(): NaN인지 판별하기 위해 사용
> 자동 자료형 변환
    > 숫자와 문자열 자료형 자동 변환
        > 숫자와 문자열에 +연산자를 적용하면 자동으로 숫자가 문자열이 됨.
            >> "52" + 273 => 52273
            >> 52 + "273" => 52273
            >> "52" + "273" => 52273
            >> 52 + 273 => 325
    > 불 자료형 자동 변환
        > !연사자를 두 번 사용해 Boolean() 함수를 사용하는 것과 같은 효과 줌
> 일치 연산자
    > ===: 자료형과 값이 같은지 비교
    > !==: 자료형과 값이 다른지 비교

    >> 52 == '52' => true   (자동 형변환)
    >> 52 === '52' => false (자동 형변환 X)
    >> 0 == '' => true      (자동 형변환)
    >> 0 === '' => false    (자동 형변환 X)
> 상수: 항상 같은 수, 변경할 수 없음
    > const con = " 변경 불가";
      con = ""; // 오류


#### Weeek4: 조건문 ####

조건문
> if 조건문
    > if(<불 표현식: true or false, 0 1만 들어가도 작동함>){    }       : 조건식이 true면 {}안의 코드 실행

    > 현재 시간 구하기
        let data = new Data() >> 생성자 함수(객체 생성)

        >> data. 옆에 있는 것은 메소드
        console.log(data.getFullYear());
        console.log(data.getMonth());
        ...
    > 오전과 오후 구분(1)
        if(data.getHours() < 12) {console.log("오전입니다.");}
        
        if(12<=data.getHours()) {console.log("오후 입니다.");}
> if else 조건문
    > if(<불 표현식>)   {}  else {}
        >> ture면 if의 {}코드 실행, false면 else의 {} 코드 실행

    > 오전과 오후 구분(2)
        let date = new Date();

        if(date.getHours() < 12) {console.log("오전입니다.");   }
        else {console.log("오후입니다.");}
> 중첩 조건문
    > if (<불표현식){
        if(<불표현식>){문장;} else {문장;}
    } else{
        문장;
    }

    > 식사시간 구분(1)
    let date = new Date();
    let hours = date.getHours();

    if(hours<11){
        console.log("아침 먹을 시간");
    } else{
        if(hours<15){
            console.log("점심 먹을 시간");
        } else {
            console.log("저녁 먹을 시간");
        }
    }
> if else-if 조건문: 중복되지 않은 세 가지 이상의 조건을 구분할 때 사용
    > if(불) {} else if(불) {} else if(불) {} else {}

    > 식사시간 구분(2)
    let date = new Date();
    let hours = date.getHours();

    if(hours<11){
        console.log("아침 먹을 시간입니다.");
    } else if(hours<15){
        console.log("점심 먹을 시간입니다.");
    } else{
        console.log("저녁 먹을 시간입니다.");
    }
> switch 조건문
    > switch(<비교할 값>){
        case <값> : 문장; break;
        case <값> : 문장; break;
        default: 문장; break;
    }

    > 홀짝 구분
    let input = 32;

    switch(input % 2){  //불이 아니라 비교 값!!
        case 0: console.log("짝수입니다."); break;  //break가 없으면 그 다음 case까지 쭉함.
        case 1: console.log("홀수입니다."); break;
    }

    > break 키워드를 사용하지 않은 조건문
    let date = new Date();

    switch(date.getMonth()+1){      //기본값이 0~으로 시작함.
        case 12:
        case 1:
        case 2: console.log("겨울입니다."); break;
        case 3:
        case 4:
        case 5: console.log("봄입니다."); break;
        case 6:
        case 7:
        case 8: console.log("여름입니다."); break;
        case 9:
        case 10:
        case 11: console.log("가을입니다."); break;
        default: console.log("어떤 행성에 사는 거임...?"); break;
    }
> 삼항 연산자
    > <불 표현식> ? <참> : <거짓>
    > ex) console.log(number % 2 == 0 ? true : false);

    > 값 비교하기(`연산자 사용)
    let numA = 52;
    let numB = 0;
    let numC = -23;

    console.log(`${numA}은/는 ${numA > 0 ? "0보다 큰" : "0 또는 0보다 작은"} 숫자입니다.');
    console.log(`${numB}은/는 ${numB > 0 ? "0보다 큰" : "0 또는 0보다 작은"} 숫자입니다.');
    console.log(`${numC}은/는 ${numC > 0 ? "0보다 큰" : "0 또는 0보다 작은"} 숫자입니다.');

    > 삼항 연산자를 활용한 변수 초기화********
        > 변수가 undefined일 때만 초기화
        let test;

        //해당 변수가 undefined(false 반환)인지 확인 후 초기화
        test = test ? test : "초기화합니다_1";
        console.log(test);

        //해당 변수가 undefined인지 확인 후 초기화
        test = test ? test : "초기화합니다_2";
        console.log(test);

        #결과: 초기화합니다_1   초기화합니다_1
> 초기화 조건문
    > let test;
    if(!test) {     //undefined가 false를 반환하기 때문에 !(not)을 붙여줌
        test = "초기화합니다_1";
    }
    console.log(test);

    if(!test){
        test = "초기화합니다_2";    //위에서 초기화 했음. 즉 실행 안함.
    }
    console.log(test);
> 짧은 초기화 조건문
    > A || B에서 A가 참이라면 A로 대치
    > A || B에서 A가 거짓이라면 B로 대치

    let test;

    test = test || "초기화합니다_1"
    console.log(test);

    test = test || "초기화합니다_2"
    console.log(test);

    #결과: 초기화합니다_1   초기화합니다_1
> 조금 더 나아가기
    > 노드는 서버에서 사용는 것. 서버에 입력을 넣을 필요는 없음. but c나 c++의 scanf처럼 서버에 직접 입력을 넣을 수 있는 방법이 있나?
    > 웹 브라우저에서 작동하는 자바스크립트: prompt() 이름의 함수를 받음
    > Node.js에서 작동하는 자바스크립트: 단순한 코드로 입력을 받을 수 없음
    > repl: 우리가 프롬포트에 node를 입력시 다음 줄에 >가 나오고 여기에 어떤 식을 넣으면 연산이 된다. 여기서 입력을 받는 것을 의미

    > 기본적 입력
    const repl = require('repl');   //repl을 갖고 옮.
    
    repl.start({
        prompt: "<입력 때 앞에 출력할 문자열>",
        eval: (command, context, filename, callback) => {
            //입력(command)을 받았을 때 처리를 수행

            //처리 완료
            callback();
        }
    });

    >> 입력 방법
    //모듈 추출
    const repl = require('repl');

    //입력 시작
    repl.start({
        prompt: "숫자 입력> ",
        eval: (command, context, filename, callback) =>{
            //입력을 받았을 때 처리를 수행
            let number = number(command);   //입력이 command로 들어옴.

            //입력이 숫자인지 확인
            if(isNaN(number)){
                console.log("숫자가 아닙니다.");
            } else {
                console.log("숫자입니다.");
            }

            //처리완료
            callback();
        }
    });
    >> '숫자 입력> '이라고 입력한 글자가 나오면서 사용자의 입력을 기다림
    >> 숫자를 입력하면 입력한 글자를 command 변수로 전달해 처리를 수행
    >> callback() 함수를 호출 '현재 처리를 종료합니다.'를 알린 후
    >> 종료하고 싶을 때는 Ctrl + C 를 연속해서 두 번 누름

########
<week5: 배열/반복문 등>

- 반복문
> 붙여 넣기를 사용한 반복
    > for while do-while 등

- 배열
> 여러 개의 자료를 한꺼번에 다룰 수 있는 자료형
> 대괄호 내부의 각 자료는 쉼표로 구분
> 배열에는 여러 자료형이 섞여 있을 수 있음
> 요소(element): 배열 안에 들어 있는 각 자료는
> 사용 >> let 배열명 = [요소, 요소, 요소 ...]
    > ex. 
        > let array = [52, 273, '아침', true]
        undefined
        > array
        [52, 273, '아침', true]
    > 배열 요소: 0부터 시작, 배열명[인덱스]로 접근

- while 반복문
    > whlie(불 표현식){불 표현식이 참인 동안 실행}  
        > 불 표현식>> true, false로만 나옴
        > flase 일 경우에 돌리기 위해 !(not)을 앞에 적어두기
        > 불 표현식이 false일 때 반복문에서 벗어남
        > 예제

        let i = 0; //불표현식을 위한 변수
        let array = [52, 273, 32, 65, 103]

        while(i<array.length){      //array 객체의 length 속성(배열 길이)을 불러옴
            console.log(i+"번빼 출력: " + array[i]);
            i++;
        }

- for 반복문의 각 단계
    > 초기식 비교, 조건식 비교(조건이 false이면 반복문 종료), 문장 실행, 종결식 실행, 2단계로...
    > for(초기식, 조건식, 종결식) { 문장 }
    > for(let i=0;i<반복횟수;i++) { 문장 }
    > 횟수가 정해질 때 사용하는 반복문
    > 예제: 0~100까지 더하기
    let output = 0;
    for(let i = 0;i<=100;i++){
        output += i;
    }
    console.log(output)
    > 예제: 1~20까지 곱셈하기
    let output = 1;
    for( let i = 1; i <= 20; i++){
        output *= i;
    }
    console.log(output);

- 역 for 반복문
    > 초기식이 작아짐
    > for(let i = length -1; i>=0;i--){문장}
    > 예제: 배열의 요소를 뒤쪽부터 출력
    let array = [1,2,3,4,5,6];

    for(let i = array.length - 1;i>=0;i--){
        console.log(array[i]);
    }
        >> 만약 5가 아닌 6부터 한다면?(초기식이 let i = array.length 였다면?) >> 다른 언어와 달리 undefined가 뜸
            > 나중에 배열에서 벗어났는지 판별할 수 있는 키가 될 수 있음

- for in 반복문과 for of 반복문
    > 객체에 쉽게 반복문을 적용함
    > 두 반복문 모두 for 반복문과 사용과 역할은 같음
    > for in: for(let 인덱스 in 배열) {} //인덱스를 받아라(인덱스는 당시에 선언한 것)
    > for of: for(let 요소 of 배열) {}   //배열의 값을 받아라(요소는 당시에 선언한 것)
    > 예제: 요소 가져오기"
    let array = ["사과", "배", "포도", "딸기", "바나나"];

    for(let i in array) {
        console.log(`${i}번째 요소: ${array[i]}`);
    }

    console.log("----구분선----");

    for(let item of array){
        console.log(item);
    }

- 중첩 반복문
    > 반복문을 여러 번 중첩해서 사용
    > 예제 별찍기
    let output = "";
    for(let i = 0;i<10;i++){
        for(let j = 0;j<i+1;j++){       //i와 j의 관련성을 주는 것
            output += '*';
        }
        output += '\n';
    }

    console.log(output);
    > 예제 별찍기2
    let output1 = "";
    for(let i=0;i<10;i++){
        for(let j=0;j<10-i;j++){    //공백 찍기
            output1+=' ';
        }
        for(let j = 0;j<i+1;j++){   //별 찍기
            output1 += '*';
        }
        output1+='\n';
    }
    console.log(output1);

- break 키워드
    > 가급적 사용하지 않음
    > 반복문을 벗어날 때 사용
        > 무한 반복문 때 반복문을 벗어나는 용도로 사용
    > 예제: 짝수를 찾으면 나가는 반복문
    let i = 0;
    let array = [1,31,273,57,8,11,32];
    let output;

    while (true){
        if(array[i] % 2 ==0){
            output = array[i];
            break;  //while문 자체를 나감
        }
        i+=1;
    }

    console.log('처음 발견한 짝수는 ${output}입니다.`);

- continue 키워드
    > 반복문 내부에서 현재 반복을 멈추고 다음 반복을 진행함
    > 예제: 홀수만 출력하기
    for(let i = 1; i< 10;i++){
        if(i%2==0){
            continue;   //continue 아래있는 문장은 돌지 않고 조건으로 돌아감
        }

        console.log(i);
    }
    > 예제: 홀수만 출력하기(advanced: continue 사용 없이 사용가능!)
    for(let i =1;i<10;i++){
        if(i%2!=0){ 
            console.log(i);
        }
    }

- 더 나아가기: 스코프
    > 변수를 사용할 수 잇는 범위
    > 스코프 == 블록
    > 블록: 중괄호로 둘러싸는 부분
    > 블록 내부에 선언된 변수는 해당 변수 내부에서만 사용가능
        > ex. {let a = 0; }     console.log(a)//불가 
        > 반복문에 활용된 변수는 해당 블록에 있으므로 외부에서 활용할 수 없음
            > ex. for(let i =0;i<10;i++){} console.log(i);//불가
    > 스코프 내부에서의 이름 중복(같은 블록에서 우선으로 찾고, 없을 시 전역으로)
        > ex
        let a = 1;
        let b = 1;
        {
            let a = 2;
            {
                let a = 3;
                console.log(a); //3
                console.log(b); //1
            }
            console.log(a); //2
            console.log(b); //1
        }

- 더 나아가기: 호이스팅
    > 해당 블록에서 사용할 변수를 미리 확인해서(컴파일러가) 정리하는 작업
    > 예제(에러발생)
    let a1 = 1;
    {
        console.log(a1);     //에러, *변수 선언 항상 앞쪽으로!*
        let a1 = 2;
    }

- 더 나아가기: var 키워드
    > let 키워드: 자바스크립트
        > let 키워드로 생성한 변수는 해당 블록(스코프) 내부에서만 사용
        > { let a = 10; } console.log(a);   //에러
    > var 키워드: 익스플로러
        > var 키워드로 생성한 변수는 모든 곳에서 사용
        > { var a = 10; } console.log(a);   //10출력

####
<week6:함수/객체>
%함수%
- 익명 함수
    > 이름을 붙이지 않고 함수 생성
    > 함수를 호출하면 함수 내부의 코드 덩어리가 모두 실행
    let <함수명> = function() {};
    > 변수에 function을 임의로 할당해 둔 것. 이 변수는 함수임.

- 선언적 함수
    > 이름을 붙여 함수를 생성
    function <함수명>() {}
    <함수명>()      >> 함수 호출
    console.log(<함수명>);      >>[Function: <함수명>]으로 출력, function 형태의 이름은 <함수명>

- 화살표 함수[ECMAScript6]
    () => {}
    > 익명 함수를 생성하는 하나의 방법, 앞에 fucntion 대신해서 =>가 들어간 형태
    > 하나의 표현식을 리턴하는 함수를 만들 때는 중괄호 생략 가능

- 함수의 기본 형태
    function <함수명>(<매개변수>) {
        <함수 코드>
        return <리턴 값>
    }
    > 함수 사용 이유: 중복된 코드를 한번만 사용할 수 있도록 만든 것

    > 예제: power() 함수 생성
    function power(x) {
        return x * x;
    }
    console.log(power(10));     //100
    console.log(power(20));     //400

    > 예제: multiply함수(매개변수가 여러개 있을 수 있음)
    function multiply(x,y) {
        return x * y;
    }
    console(multiply(52,273));
    console(multiply(103, 32));

    > 예제: print함수(리턴이 없을 수 있음)
    function print(message) {
        console.log(`"${message}"(이)라고 말했습니다.`);
    }
    print("안녕하세요");
    print("뿌잉뿌잉");

    > 예제: sum함수(함수 내에 있는 변수 반환 가능)
    function sum(min, max){
        let output = 0;
        for(let i = min; i<=max;i++){
            output+=i;
        }
        return output;
    }
    console.log(sum(1,100));

    > 매개 변수를 입력하지 않고 함수 호출하면 undefined 출력
    function(print(name, count)){
        console.log(`${name}이/가 ${count}개 있습니다.`);
    }
    print("사과", "10");        //사과이/가 10개 있습니다.
    print("사과");              //사과이/가 undefined개 있습니다.
    > 이를 방지하기 위해 매개 변수 초기화
    function(print(name, count)){
        //첫번째 방법: if문 사용
        if(!count){      //count를 입력하지 않으면 undefined됨. boolean으로는 false.
            count = 1;
        }
        //두번째 방법: 짧은 초기화 조건문 사용
        count = count || 1;     //count가 ture면 count 대입, false면 1 대입.

        console.log(`${name}이/가 ${count}개 있습니다.`);
    }
    print("사과");

- 콜백 함수
    > 함수의 매개 변수를 전달되는 함수(매개변수에 들어가는 함수)
    > 예제: 콜백 함수 사용
    function callTenTimes(callback){    //callback: 매개변수로 함수가 들어온다는 뜻(꼭 callback으로 쓰지 않아도 괜찮, a로 해도 상관없음)
        for(let i = 0;i<10;i++){
            callback();     //매개 변수로 들어온 callback함수 실행.
        }
    }
    callTenTimes(function() {       //callTenTimes 함수에 console.log("함수 호출");을 하는 function이 입력된 거임.
        console.log("함수 호출");
    });
    >> callTenTimes(function(){console.log("함수 호출")});

- 표준 내장 함수
    > 자바스크립트에서 기본적으로 지원하는 함수
    > 종류(몇개만)
    parselnt() > 문자열을 정수로 변환. Number과는 다르게 숫자 뒤에 오는 문자(ex. 1004개 에서 개)는 자동으로 삭제해줌. but Number로 쓰는 경우도 많음
    parseFloat() > 문자열을 실수로 변환
    Number() > 강제 형변환(숫자로)
        > 예제: parselnt와 parseFloat 함수
        let inputA = "52";
        let inputB = "52.27";
        let inputC = "1401동";

        console.log(parselnt(inputA)));     //52

        console.log(parselnt(inputB));      //52
        console.log(parseFloat(inputB));    //52.273

        console.log(parseInt(inputC));      //1401

    > 타이머 함수: 특정 시간 후 or 특정 시간마다 어떤 일을 할 때 사용. 밀리초로 지정(1초는 1000밀리초)
    setTimeout(함수, 시간)  > 특정 시간 후 함수 실행
    setInterval(함수, 시간) > 특정 시간마다 함수 실행
        > 예제: 타이머 함수
        //1초 후에 실행
        setTimeout(function() {console.log("1초가 지났습니다.");}, 1000);
        //1초 마다 실행
        setInterval(function() {console.log("1초 마다 호출됩니다.");}, 1000);
        >> 종료 하려면 Ctrl+c
    clearInterval(아이디) > 특정 시간마다 실행하던 함수 호출을 정지
        > 예제: clearInterval, 3초 후에 그만 두는 함수
        let id = setInterval(function() {console.log("출력합니다.");}, 1000);
        setTimeout(fucntion(){clearInterval(id);}, 3000);   

- 조금 더 나아가기
    > 익명 함수와 선언적 함수의 생성 순서
        > 변수에 새로운 값을 덮어썼을 때, 마지막에 입력한 값이 되는 것처럼, 함수도 마지막에 덮어쓴 함수로 대체됨.
            let 함수;
            함수 = function() {console.log("첫 함수");};
            함수 = function() {console.log("다음 함수");};
            함수 ();    //다음 함수 출력
        > 익명 함수와 선언적 함수가 같이 있을 때는 익명 함수가 실행됨.
        let 함수 = function() {console.log("첫 함수");};
        function 함수() {console.log("두번째 함수");};
        함수(); //첫 함수 출력
            >> 이유: 익명 함수는 실행 될때, 선언적 함수는 적힐 때 선언이 됨. 그래서 불러올 때는 실행 할 때 선언되는 익명함수로 사용

    > 익명 함수와 화살표 함수의 차이**
        > 내부에서 this 키워드가 갖는 의미
        (function() {console.log(this);})();    //익명함수 상위 객체를 가리키는 것. 그래서 오류
        (()=>{console.log(this);})();       //{} 출력, this는 자신을 가리킴

%객체%
- 객체 기본
    > 배열(배열의 선언과 객체의 선언이 유사한 부분이 있음)
        let array = ["사과", "바나나", "망고", "딸기"];
        > 배열 접근: []사용. 인덱스(0~)를 사용해 요소 접근, 객체는 키(속성)를 사용!!
        array[0]= "사과";
        array[1] = "망고";

    > 객체
        let product = {
            제품명: "건조 망고",    //console.log로 출력시 제품명도 '제품명'으로 나옴.
            유형: "당절임",
            성분: "망고, 설탕, 메타중아황산나트륨, 치자황색소",
            원산지: "필리핀"
        };
        console.log(product);   //출력형태는 JSoN(Java Script object Notation: 자바스크립트 객체 기반의 표현)과 비슷
        >> 여기서 "제품명" "유형" "성분"은 키(속성), "건조망고" 등은 속성(속성값)임.
        >> ,로 속성
    > 객체 접근: <객체명>.키(속성)
        product['제품명'] 으로 접근 가능하나, 번거롭기 때문에
        product.제품명 으로 접근하는 경우가 많음
    > 예제: 객체 생성
    let object = {
        name: "바나나",
        price: 1200;
    };  //;꼭 붙이기!!!
    console.log(object.name);   //바나나
    console.log(object.name);   //1200
    > 예제: 객체와 반복문, for in으로(인덱스, 객체에서 키(속성)으로)  접근
    let object = {
        name: "바나나",
        price: 1200;
    };
    for( let key in object){
        console.log(`${key}: ${object[key]}`);  //인덱스로 받아오기 때문에 []사용
    }
        >> name: 바나나 (\n) price: 1200

- 속성과 메소드
    > 요소: 배열 내부에 잇는 값 하나하나
    > 속성: 객체 내부에 있는 값 하나하나(위 object 객체에서 name, price는 속성명(키,속성), "바나나", 1200은 속성(속성,속성값))
    > 객체에서는 다양한 자료형을 사용할 수 있음. (객체 내부의 함수는 메소드라고 부름)
    > 메소드: 객체의 속성 중 자료형이 함수인 속성
    let object = {
        name: "바나나",
        price: 1200;
        print: function() {//외부에서는 object.print()로 접근 가능(메소드는 () 써야함.)
            //this는 함수 밖에 있는 것을 의미, 여기에서는 object 객체 내부를 지칭(객체 내부의 name과 price)
            console.log(`${this.name}의 가격은 ${this.price}원 입니다.`);   
        }   
    };

- 생성자 함수와 프로토타입
    > 객체 지향 프로그래밍: 현실의 객체를 모방해서 프로그래밍
    > 배열과 객체를 사용하면 여러 개의 데이터를 쉽게 다룰 수 있음.*****
        > 예제: 객체 배열
        let product = [ //배열(객체를 요소로 갖는 배열)
            {name: "바나나", price: 1200},  //객체
            {name: "사과", price: 2000},    //객체
            {name: "배", price: 3000},      //객체
        ]
        > 예제: 객체에 메소드 추가(비효율적)
        let product = [ //배열(객체를 요소로 갖는 배열)
            {name: "바나나", price: 1200, print: function() {.....}},  
            {name: "사과", price: 2000, print: function() {.....}},    
            {name: "배", price: 3000, print: function() {.....}},      
        ];
        for(let product of products) {      //배열에 접근하는 것이라 for-of사용
            product.print();    //각 요소의 print메소드 접근(product[0].print()같은 의미)
        }
            >> 각 요소(객체)에 같은 코드가 많음
        > 예제: 함수를 외부로 내보낸 형태(함수를 사용해 같은 함수를 선언함)
        (위에 코드에 이어서...)
        fucntion printProduct(product) {
            console.log(`${this.name}의 가격은 ${this.price}원 입니다.`);
        }
        for(let product of products){
            printProduct(product);      //products의 요소(객체형)를 printProduct 함수에 매개변수로 이용
        }
            >> 잘못됨: 객체를 지향하는 프로그래밍이 아님. print함수가 객체 밖에 있음.
    > 생성자 함수: 객체를 만드는 함수, 대문자로 시작하는 이름 사용
     function Product(name, price) {    //객체를 만드는 함수(앞에 대문자)
         this.name = name;  //this. 뒤에 있는 것은 객체의 키(속성)
         this.price = price;
     }
     //객체 생성: 생성하기 때문에 "new" 키워드 반드시 사용해야함!!!!**
     let product = new Product("바나나", 1200);
     console.log(product);     //Product { name: 'Banana', price: 1200 } 객체 이름도 나옴!
    > 프로토타입: 생성자 함수로 만든 객체는 프로토타입 공간에 메소드를 지정해서 모든 객체가 공유 하도록 함. 해당 함수를 생성자 함수(new)로 사용했을 때만 의미 잇음
        > 예제: 프로토타입
        function Product(name, price) {    
            this.name = name;  
            this.price = price;
        }
        //프로토타입에 메소드 선언: Product객체의 prototype 공간에 print라는 메소드 정의
        Product.prototype.print = function(){
            console.log(`${this.name}의 가격은 ${this.price}원 입니다.`);
        };
        //객체 생성: new 반드시 사용!!
        let product = new Product("바나나", 1200);  
        //메소드 호출
        product.print();
            >> product.print()를 실행시, 객체 생성 코드로 이동, 여기서 Product 생성자 함수로 감. 하지만 생성자 함수에는 print메소드가 없음. 그럼 Product의 prototype 공간으로 이동. 그곳에 있는 print메소드 실행
    > 예제: 객체 지향적으로 구성한 객체 배열
     //생성자 함수
     function Product(name, price){
         this.name = name;
         this.price = price;
     }
     //프로토타입에 메소드 선언: 만약 생성자 함수에 print메소드를 설정시, new로 불러올 때마다 메모리에 쌓임(즉 프로토타입이 더 메모리적으로 효율적)
     Product.prototype.print = function(){
         console.log(`${this.name}의 가격은 ${this.price}원 입니다.`);
     };
     //상품 목록 선언
     let products = [
         new Product("바나나", 1200),   //Product객체에는 print가 없음. 다만 prototype에 연결 되어 있음
         new Product("사과", 2000),
         new Product("배", 3000)
     ];
     //반복 출력
     for(let product of products){
         product.print();
     }

- 조금 더 나아가기
    > null의 값과 자료형
        console.log(null);  //null
        console.log(typeof(null));  //object 즉, null도 객체임
    > null: 아예 값이 없는 상태를 구분할 때 사용
    > 예제: 존재하지 않는 값 확인
     let zeroNumber = 0;
     let falseBoolean = false;
     let emptyString = '';
     let undefinedValue;    //undefined, 초기화 하지 않아서 비어있는 상태(초기화시)
     let nullValue = null;  //중간에 사용하다 빈 값을 사용해야할 때 사용(프로그램 사용 중에)
     //값이 있는지 확인
     if(zeroNumber == null)
        console.log('0은 존재하지 않는 값입니다.');
     if(falseBoolean == null)
        console.log('false는 존재하지 않는 값입니다.');
     if(emptyString == null)
        console.log('빈 문자열은 존재하지 않는 값입니다.');
     if(undefinedValue == null) //undefined는 false면서 null임, undefined와 null만 null에 같음
        console.log('undefined는 존재하지 않는 값입니다.');
     if(nullValue == null)
        console.log('null은 존재하지 않는 값입니다.');
        >> undefined는 존재하지 않는 값입니다.(\n)null은 존재하지 않는 값입니다.

####
<week7: 표준 내장 객체, 예외 처리, this 알아보기>
#표준 내장 객체
- 기본 자료형과 객체 자료형의 차이(모질라 싸이트 들어가보기)
    > 통합 개발 환경(ID)에서 자동 완성 기능이 있어, 많은 자료형/객체를 쓸 수 있음
    > 기본 자료형: 숫자, 문자열, 불
        > typeof로 자료형 알 수 있음.
        let number = 273; let string = "hello"; boolean = true; 등
    > 객체 숫자, 문자열, 불
        > 객체로 만들 수 있음
        let number = new Number(273); let string new String("hello"); 등
        but typeof로 출력시 모두 객체(object)로 출력됨.
    > 기본 자료형의 속성 또는 메소드를 사용할 때는 기본 자료형이 자동으로 객체로 변환됨. (기본, 객체 자료형 모두 속성과 메소드를 사용할 수 있음)
        > let string = "과자|1500원"; //typeof는 String 출력
        > let string = new String("과자|1500원");   //typeof는 object 출력
        >> console.log(string.split('|')); //['과자', '1500원']: 둘 다 이렇게 나옴(둘다 split 메소드 사용 가능)
    > 차이점: 기본 자료형은 객체가 아님. 즉 속성과 메소드를 추가할 수 없음.
        let primitiveNumber = 273;
        primitiveNumber.method = function () {
            return primitiveNumber;
        };
        console.log(primitiveNumber.method());  //오류. 메소드 추가 못함.
    > 기본 자료형에 프로토타입으로 메소드 추가할 수 잇음
        let primitiveNumber = 273;
        Number.prototype.method = function () {     //primi~ 이 메소드를 사용 시 Number 객체로 변환됨. >> Number의 prototype에 메소드를 추가하면 사용 가능!
            return 'primitiveNumber';
        };
        console.log(primitiveNumber.method());

- Number 객체
    > 자바스크립트에서 숫자를 표현할 때 사용
    > 예제: Number 객체 생성
        let numberFromLiteral = 273;    //기본자료형으로 생성
        let numberFromConstructor = new Number(273);    //객체 자료형으로 생성
    > 메소드(문자열로 리턴)
        > toExponential(): 숫자를 지수 표시로 나타낸 문자열로 리턴
        > toFixed(): 숫자를 고정소수점 표시로 나타낸 문자열을 리턴합니다.
        > toPrecision(): 숫자를 길이에 따라 지수 표시 or 고정소수점 표시로 나타낸 문자열로 리턴
    > 예제: Number의 메소드(toFixed(num)는 소수점 num 자릿수까지 자름)
        let number = 273.5210332;
        console.log(number.toFixed(1)); //273.5
        console.log(number.toFixed(4)); //273.5210
    > 예제: 생성자 함수 속성
        function Constructor() {};  //생성자 함수 
        Constructor.property = 273; //생성자 함수에 변수 추가!
        Constructor.method = function () {};    //생성자 함수에 메소드 추가~!
        console.log(Constructor.property);  //273
        console.log(Constructor.method());  //[ Function ]

        >> 생성자 함수의 속성
        MAX_VALUE: 자바스크립트의 숫자가 나타낼 수 있는 최대 숫자
        MIN_VALUE: 자바스크립트에서 숫자가 나타낼 수 있는 최소 숫자
        NaN: 숫자로 타나낼 수 없는 숫자
        POSITIVE_INFINITY: 양의 무한대 숫자
        NEGATIVE_INFINITY: 음의 무한대 숫자
    > 예제: 생성자 함수의 속성사용(MAX_VALUE)
        let numberA = Number.MAX_VALUE;
        let numberB = Number.MAX_VALUE + 1;
        console.log(numberA);
        console.log(numberB);
        >> 1을 추가한 numberB와 numberA의 값이 같음.
    > 예제: 생성자 함수의 속성 사용(NEGATIVE_INFINITY)
        let addNumber = new Number('0.00000000000000001e+308'); //너무 큰 수는 부동소수점으로 사용!
        let number = Numbe.MAX_VALUE + addNumber;
        console.log(number);

- String 객체
    > 생성
        let stringFromLiteral = "hello";
        let stringFromConstructor = new String("hello");
    > 속성과 메소드(String 객체의 메소드는 변경된 값을 리턴함)**
        > length: 문자열의 길이를 나타냄.
        > indexOf(searchString, position): 앞에서부터 일치하는 문자열의 위치를 리턴함.(없으면 -1 리턴)
        > replace(regExp, replacement): regExp를 replacement로 바꾼 후 리턴
        > slice(start, end): 특정 위치의 문자열을 추출해 리턴
        > split(separator, limit):separator로 문자열을 잘라 배열 리턴
        > toLowerCase(): 문자열을 소문자로 바꾸어 리턴
        > toUpperCase(): 문자열을 대문자로 바꾸어 리턴
    > 예제: 잘못된 String 객체 메소드 사용(비파괴적인 메소드인 toUpperCase())
        let string = 'abcdefg';
        string.toUpperCase();   //ABCDEFG
        console.log(string);    //abcdefg로 출력! toUpperCase로 바꾼 배열을 저장해주지 않음!
    > 예제: 올바른 String 객체 메소드 사용
        let string = 'abcdefg';
        string = string.toUpperCase();
        console.log(string);    //ABCDEFG로 출력!
    > 예제: 문자열 포함 여부(indexOf() 메소드로 문자열이 있는지 확인, 없으면 -1리턴)
        let string "안녕하세요. 좋은 아침입니다.";
        if(string.indexOf("아침") >= 0) {
            console.log("좋은 아침이에요!");    //출력됨.
        }
    > 예제: 문자열 분해(split()도 비파괴적으로 사용 됨.)
        let string = '감자, 고구마, 바나나, 사과';
        let array = string.split(',');
        console.log(array); 

- Date 객체
    > 객체 생성
        new Date(): 현재 시간으로 Date() 객체 생성
        new Date(<유닉스타임>): 1970.1.1, 0시 0분 0초에서 부터 경과한 밀리초로 Date객체 생성(많이 사용!)**
        new Date(<시간 문자열>): 문자열로 Date 객체 생성
        new Date(<년>, <월-1>, <일>, <시간>, <분>, <초>, <밀리초>): 시간 요소 기반으로 Dat 생성
        >> 월은 0부터 시작.
    > 예제: 객체 생성
        //현재 시간 기반
        let dateA = new Date();
        console.log(dateA); //2021-04-16T01:13:39.108Z
        //유닉스 타임
        let dateB = new Date(692281800000);
        console.log(dateB); //1991-12-09T12:30:00.000Z
        //문자열 기반 Date 객체
        let dateC = new Date("December 9, 1991 21:30:00");
        console.log(dateC); //1991-12-09T12:30:00.000Z
        //시간 요소 기반 Date 객체
        let dateD = new Date(1991, 12-1, 9, 21, 30, 0,0);
        console.log(dateD); //1991-12-09T12:30:00.000Z
    > 메소드 활용(모질라 참고)
        get~()/set~() 형태 메소드: ~에 FullYear, Month, Day, Hours, Minutes, Seconds를 사용하여 불러오거나 설정할 수 있음
    > 예제: 시간 더하기(현재로 부터 1년 11개월 7일을 더한 날자 출력)
        let date = new Date();
        console.log(date);
        date.setFullYear(date.getFullYear() +1);
        date.setMonth(date.getMonth() + 11);
        date.setDate(date.getDate() + 7);
        console.log(date);
    > 예제: 시간 간격 구하기(getTime() 메소드(유닉스 타임), 2개의 시간을 빼고 일단위로 나누어 시간 간격 구하기)
        let now = new Date();
        let before = new Date("May 9, 2001");
        //시간간격 구하기
        let interval = now.getTime() - before.getTime();
        interval = Math.floor(interval/(1000*60*60*24));// 일단위로 나누기!
        //출력
        console.log(`태어나고 ${interval}일 지났습니다.`); //태어나고 7282일 지났습니다.

- Array 객체
    > 기본 메소드: 대부분 파괴적 메소드, 자기 자신을 변경
        concat(): 변수로 입력한 배열 요소를 모두 합쳐 배열을 리턴
        join(): 배열 안의 모든 요소를 문자열로 만들어 리턴
        pop()*: 배열의 마지막 요소를 제거하고 리턴
        push()*: 배열의 마지막 부분에 새로운 요소 추가
        reverse()*: 배열의 요소 순서 뒤집기
        slice(): 배열 요소의 지정한 부분 리턴
        sort()*: 배열의 요소 정렬
        splice()*: 배열의 요소의 지정한 부분을 삭제하고 삭제한 요소 리턴
        >> *표시 되어 있는 것은 파괴적 메소드!!
    > 예제: 메소드 연습(code7-21.js 파일 참고)
    > 예제: 배열 정렬(code7-9.js 파일 참고, sort(): 오름차순(사전, 숫자 순))
    > ECMAScript5에 추가된 메소드(모질라 레퍼런스 사이트 참고)
        forEach(): 배열의 요소를 하나씩 뽑아 반복 돌림
        map(): 콜백 함수에서 리턴하는 것을 기반으로 새로운 배열을 만듬(변수 지정!)
        filter(): 콜백 함수에서 true를 리턴하는 것으로만 새로운 배열을 만들어 리턴(변수 지정)
        > 예제: 추가된 메소드 사용하기(code7-24 참고)

- 조금 더 나아가기
    > 프로토타입에 메소드 추가
        > 프로토타입에 메소드를 추가하면 해당 자료형 전체에 추가 가능
        > 예제: String 생성자 함수의 prototype 속성에 contain() 메소드 추가
         String.prototype.contain = function (input) {
             //string에 input이 있는가?
             return this.indexOf(input) >= 0;
         };
         //메소드 활용
         console.log("안녕하세요".contain("안녕"));
         console.log("안녕하세요".contain("데굴데굴"));
    > underscore.js 라이브러리(정렬하기 좋음)
        > 설치 해야함.(npm install underscore);
        > html에서 사용시 <Script src="http://underscorejs.org/underscore.js"></Script>로 표시 해줘야함.
        > 예제: underscore.js 라이브러리를 사용한 정렬(code7-25.js 참고)
    > JSON 객체: 자바스크립트 객체를 사용한 데이터 표현 방법
        > 기본 형태
        [
            {
                "name": "고구마",   //키에 속성이 들어가 있는 형태
                "price": 1000
            },
            {
                "name": "감자",
                "price": 500
            },
            {
                "name": "바나나",
                "price": 1500
            }
        ]
        > 제약 사항
            > 문자열은 큰따옴표로 만듬
            > 모든 키는 큰따옴표로 감싸야함
            > 숫자, 문자열, 불 자료형만 사용가능! (기본자료형)
        > 메소드
            JSON.stringify(<객체>, <변환 함수>, <공백 개수>): 자바스크립트 객체를 문자로 만들기
            JSON.parse(<문자열>): 문자열을 자바스크립트 객체로 피싱함
        > 예제: JSON 객체 활용하기(code7-26.js 확인)

#예외처리
- 예외와 기본 예외 처리
    > 예외: 실행에 문제가 발생하면 자동 중단됨. 이렇게 발생한 오류(오류 속에 예외가 있다고 볼 수도 있음. 오류는 실행 전에 일어나는 오류. 예외는 실행 중에 일어나는 오류)
        > 보통 사용자 UI에서 많이 발생함(예측하지 못한 행동(값 입력 등)을 했을 때 일어남)
    > 예외 처리: 오류에 대처할 수 있게 하는 것
    > 기본 예외 처리(TypeError)
        > 예제: 예외 상황 확인, undefined 자료형을 일반적인 객체 혹은 함수처럼 다루면 TypeError 예외 발생
        fucntion callThreeTimes(callback) { //매개변수로 변수가 들어와야하는데
            for(let i = 0;i<3;i++){
                callback();
            }
        }
        //정상 실행
        callThreeTimes(function() {console.log("안녕하세요");});
        //예외 발생
        callThreeTimes();   //매개변수로 아무것도 안들어옴(undefined) 예외 발생

        > 예외 처리: 사전에 해당 데이터가 undefined인지 조건문으로 확인
        function callThreeTimes(callback) {
            if(callback){
                for(let i = 0;i <10;i++){
                    callback();
                }
            } else{
                console.log("매개 변수 callback이 지정되지 않았습니다.");
            }
        }
        //정상 실행
        callThreeTimes(function() {console.log("안녕하세요");});
        //예외 발생
        callThreeTimes();   //if문에 걸리지 않고 else문으로 넘어가 오류 매시지 출력함

- 고급 예외 처리
    > try catch finally 구문
        try{
            //예외가 발생하면
        } catch(exception){
            //여기서 처리
        } finally {
            //여기는 무조건 처리
        }
    > 보통 try-catch, try-finally문으로 사용함.
    > 예제: 배열을 생성할 때 길이를 음수로 지정하면 RangError 발생
        const array = new Array(-200);  //오류 발생!
    > 예제: 고급 예외 처리
        try{
            const array = new Array(-200);
        } catch(exception) {    //예외 유형이 exception에 들어감.
            console.log(`${exception.name} 예외가 발생했습니다.`);
        } finally {
            console.log("finally 구문이 실행되었습니다.");
        }
            >>RangError예외가 발생했습니다. (\n) finally 구문이 실행되었습니다.

- 예외 객체
    > 예외가 발생하면 어떤 예외가 발생했는지 정보를 전달함
    > catch 구문의 괄호 안의 변수
    > name 속성과 message 속성이 있음.
        try{

        }catch(exception){      //자바스크립트 플랫폼에서 자동으로 예외 객체를 exception에 줌

        }
    > 예외 객체: ReferenceError 후에 예외 객체의 name과 message가 출력됨.
        try{//예외 발생
            error.error.error();
        } catch (e) {
            console.log(e.name);
            console.log(e.message);
        }

- 예외 객체 발생
    > throw 키워드 사용: 강제로 예외 발생
    > throw 키워드 뒤에는 문자열 또는 Error 객체를 입력
        throw "강제 예외";
    > 자세한 예외 출력은 Error 객체 사용: 사용시 몇 번째 줄에서 예외가 발생했는지 알 수 있음
    > 예제: 객체를 사용한 예외 강제 발생
        //Error 객체를 사용한 임의의 예외 객체 생성
        const error = new Error("메시지");
        error.name = "내 마음대로 오류";
        error.message = "오류의 메시지";
        //예외를 발생
        throw error;
    
    > 예제: 간단한 예외 강제 발생 때의 예외 객체(문자열 사용하여 예외 발생)
        try{
            //예외를 강제로 발생시킴
            throw "예외가 발생했습니다";
        } catch(exception) {
            //예외 객체를 출력합니다.
            console.log("예외가 발생했습니다.");
            console.log(exception);
        }
            >> 예외가 발생했습니다. \n 예외가 발생했습니다  : catch 구문에서 차례로 출력됨
    
    > 예제: Error 객체를 사용한 예외 강제 발생 때의 예외 객체
        try{
            const error = new Error("메시지");
            error.name = "내 마음대로 오류";
            error.message = "오류의 메시지";

            throw error;
        } cath(exception){
            console.log(`${exception.name} 예외가 발생했습니다.`);
            console.log(exception.message);
        }
>> 우선적으로 코딩을 잘 하고, 나중에 예외가 나올만한 상황에 try-catch문을 사용하는 것이 좋음